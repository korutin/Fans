// Parse_INSTRUCTION_TO_DEPO_PLACE_STORAGE(%DOC_ID:int; %Mute, %PPNum:str; %PPData:datetime; %PCode, %POutNum:str;%B, ErrList)
// ------------------------------------------------------------------------------------------------------------------------
//
// Анализ и распаковка типа INSTRUCTION_TO_DEPO_PLACE_STORAGE из форматов 1-5-0 Инфинитум
//  *** Поручение на изменение места хранения    (R03-4) ***
//
// В каталоге MACROS должен присутствовать файл со схемой. Имя фиксированное specdep_xml_1_5_0.xsd
// Чтобы проверка включалась должна быть подожжена галочка "Контроль XML корректности структуры сообщений" на форме "Системные настройки" 
// EKS 03.2019

var SenderDocNum, SenderDocDate, BErrList;

var COMMENT, RUBRICA, CREATOR, ID, D_CAT, D_ID,
    doc_state:=Extract('Данные', [select ID from OD_DOC_STATES where SYS_NAME='START']),   //BEGIN_XML
    WHOS := _Sys_Setings_F.OD_SETS._WHOS;
    
var x_main, x_account_dtls, x_autorised_person, x_transaction, x_data_storag,
    x_state_reg_num, x_contragent, x_data_storag_new;
// Всяческие рабочие/временные переменные
var Info_cr := '', ContrCount, f_doc,
    _rstroka_1, _rstroka_2, DebugLog, ErrTag, Gdoc, cc2, cc, r_doc, ErrStr, rez, DD1, DD2, body, status, err, i, fSTATE,
    PNum, PData, direction;
// Переменные ассоциированные с элементами xml документа    
var account_IDs, account_type, account_name, Account, payment_term_type_code_1, narrative_1,
    payment_term_type_code, narrative, Info, authorised_person_type, bases_of_powers, 
    v_autorised_person_ids, v_autorised_person_s_type, v_security_code, v_proprietary_security_code, v_NumReg, v_ISIN, v_CFI,
    v_AccH_ids, v_account_section_depo_id, account_holder_party_name, v_account_depo_id, v_data_storag_party_name, ds_account_section_storage_ids, ds_account_storage_ids,
    v_new_account_depo_id, v_new_account_section_depo_id, v_data_storag_new_party_name, dsnw_account_storage_ids, dsnw_account_section_storage_ids,
    v_add_info, v_AMOUNT, v_ccy_code, v_ccy_amount, v_based_info, v_bi_other, v_doc_type, v_doc_type_code,
    v_contr_stype, v_contr_full_name, v_contr_inn, v_contr_birthdate, v_contr_place_of_birth, v_contr_doc_type, v_contr_doc_type_xml, v_contr_doc_ser, v_contr_doc_num, v_contr_doc_dat, v_contr_DOC_PLACE, v_contr_OGRN, v_contr_OGRN_PLACE, v_contr_OGRN_DATE,
    v_contr_stype_2, v_contr_full_name_2, v_contr_inn_2, v_contr_birthdate_2, v_contr_place_of_birth_2, v_contr_doc_type_2, v_contr_doc_type_xml_2, v_contr_doc_ser_2, v_contr_doc_num_2, v_contr_doc_dat_2, v_contr_DOC_PLACE_2, 
    v_contr_OGRN_2, v_contr_OGRN_PLACE_2, v_contr_OGRN_DATE_2, v_contr_nationality, v_contr_nationality_2,
    v_sd_ndc, v_sd_type, v_sd_id, v_section, 
    v_name_settlement_place_dep, v_sd_other, v_sd_other_type, v_section_dep, 
    v_name_settlement_place_reg, v_acc_other, v_acc_other_type, v_nmnl_depo_acc, v_nmnl_depo_acc_type, v_nmnl_nmnl_depo2_name, v_nmnl_nmnl_depo2_acc;
    
var PhantomDoc := Table( SYS_NAME str, NUM str, CONTR_DATE date, CLIENT int, CAGENT int, PARTY_TYPE int, FROM_FACE int, RELATION int);
var STable     := Table (Rekviz str, critic bool, Info Str, type str, v_str str, v_int int, v_float float);
var LoLog      := Table (Rekviz str, tags_descr str, tags str, critic int, Info Str);
var AccPlan    := Extract('Данные', [select ID from OD_ACC_PLANS where WHOS=:WH and SYS_NAME='DEPO_BANK'], MyFace);
// ===== Реквизиты поручения ======
var SYS_NAME  := null,
    PARAM := null,
    PASS_KIND := null,
    D_DATE := null,
    NUM       := clear(''),
    CLIENT    := clear(0),
    FROM_FACE := -1,
    SHARE     := clear(0),
    LINE      := clear(0),
    CAGENT    := clear(0),
    G_TEXT    := null,
    AMOUNT    := null,
    G_CLASS   := null,
    G_NUM     := null,
    G_DATE    := null,
    D1_DATE   := null,
    D1_NUM    := null;

var REKVIZITUS := List('PARAM','PASS_KIND','D_DATE','NUM','CLIENT','FROM_FACE','SHARE','LINE','CAGENT','G_TEXT','AMOUNT','G_CLASS','G_NUM','G_DATE','D1_DATE','D1_NUM');

// сегмент переменных заполняемых из XML документа;
x_autorised_person     := null;
x_transaction          := null;
x_state_reg_num        := null;
x_data_storag          := null;
x_data_storag_new      := null;

authorised_person_type      := null;
payment_term_type_code      := ''; 
narrative                   := ''; 
payment_term_type_code_1    := ''; 
narrative_1                 := '';
v_autorised_person_s_type   := null;
v_security_code             := List(); 
v_proprietary_security_code := List();
v_NumReg                    := ''; 
v_ISIN                      := '';
v_CFI                       := '';
v_account_depo_id           := '';
v_account_section_depo_id   := '';
v_data_storag_party_name    := '';
v_add_info                  := '';
v_AMOUNT                    := null;
v_based_info                := List();
v_bi_other                  := List();
v_doc_type                  := '';
v_doc_type_code             := '';
//data_storag_party_ids       := List():=
v_contr_stype := v_contr_stype_2               := null;
v_contr_full_name := v_contr_full_name_2       := '';
v_contr_nationality := v_contr_nationality_2   := '';
v_contr_doc_type := v_contr_doc_type_2         := 0;
v_contr_doc_type_xml := v_contr_doc_type_xml_2 := '';
v_contr_doc_ser  := v_contr_doc_ser_2          := '';
v_contr_doc_num := v_contr_doc_num_2           := '';
v_contr_doc_dat := v_contr_doc_dat_2           := clear(date('31.12.1899'));
v_contr_DOC_PLACE := v_contr_DOC_PLACE_2       := '';
v_contr_OGRN := v_contr_OGRN_2                 := '';
v_contr_OGRN_PLACE := v_contr_OGRN_PLACE_2     := '';
v_contr_OGRN_DATE := v_contr_OGRN_DATE_2       := clear(date('31.12.1899'));
v_sd_ndc                       := List();
v_sd_type                      := '';
v_sd_id                        := List(); 
v_section                      := List(); 
v_name_settlement_place_dep    := '';
v_sd_other                     := List();
v_sd_other_type                := '';
v_section_dep                  := List();
v_name_settlement_place_reg    := '';
v_acc_other                    := '';
v_acc_other_type               := '';
v_nmnl_depo_acc                := ''; 
v_nmnl_depo_acc_type           := ''; 
v_nmnl_nmnl_depo2_name         := '';
v_nmnl_nmnl_depo2_acc          := '';

ds_account_storage_ids         := List();
ds_account_section_storage_ids := List();
DebugLog                       := List();

ErrList   := List();
Gdoc      := 0;
direction := 0;
fSTATE  :=2;       // Состояние по умолчанию в котором создается ЗЖРД

// ---------------- Проверяем наличие Входящего ЗЖРД к Входящему сообщению %DOC_ID -----------------
for 'Данные' select [
    select f.DOC
       from OD_STEPS s
              left join D_FILER f on f.DOC = s.A_DOC 
    where s.DOC=:DOC  and s.S_TYPE=0 and s.ERR_CODE=2004/*входящий образ*/   --d.WHOS=11286 
             and f.DOC is not null ]
from %DOC_ID
into f_doc
do
    _F_DOC->Link_Del(%DOC_ID, f_doc, 2004);
    // - Если решим что привязанный образ надо удалять - то раскоментировать строку ниже
    ExecSQL('Данные', [delete from OD_DOCS where ID = :doc], f_doc);
end;
// -------------------------------------------------------------------------------------------------

iif (%mute, dummy,
   StartProgress('Распаковка документа',
                   List('Разбор XML - файла',
                        'Поиск идентификаторов в XML',
                        'Создание нового документа - Поручение на перемещение')));

iif(%mute, dummy, DoProgress(0, 0, 1));

if (~isNull(%doc_id)) then
    body   := Extract( 'Данные', 'select BODY from D_IN_MESS where DOC=:D', %doc_id);
else
    body   := %B;
end;
// ---------------- Проверка структуры XML документа на соответствие XSD схеме -----------------
if (_Sys_Setings_F.OD_SETS._SAVE_MODE = 1) then 
   if (_F_IXML150->Check_xml_content(body, 'specdep_xml_1_5_0', %mute, ErrList)<>1) then
      if %mute then  
          return(100)
      else
          raise(ErrList);
      end;          
   end;
end;

iif(%mute, dummy, DoProgress(0, 1, 1));
iif(%mute, dummy, DoProgress(1, 0, 1));

//var x:=_Metal_F->XML_Open(%B,'I_WRITE_OFF_ed');
x_main := _Metal_F->XML_Open(body, '');
ID     := Gen_ID('Данные', 'OD_DOCS_ID_GEN' , 1);

SelectSQL('Данные', [select NUM, NAME from OD_USR_TABS where CODE='RUBRICATOR' and DOP=:N], %PCode, RUBRICA, COMMENT,exit); //пытаемся найти рубрику по наименованию поручения
SelectSQL('Данные', [select ID from OD_OPERATORS where f_Left(f_Upper(USER_DOL),9)='CODE=AVTO'], CREATOR, exit); //хотят опеарциониста с таким вот признаком

try
    // Разбираем шапку
    _F_IXML150->Inp_out_doc(x_main, PNum, PData);

    // --------------------------------------------------------------------------------------------------------------------------------------
    // Разбираем всё остальное
    // --------------------------------------- Закачиваем информацию исходя из описания в XSD схеме -----------------------------------------
  
    // ==========================================================
    //                    --- account_dtls ---
    // ==========================================================

    TableFind(STable, List('Rekviz=CLIENT'));
    if x_main.?account_dtls then
        x_account_dtls := x_main._account_dtls;
        _F_IXML150->Inp_account_dtls(x_account_dtls, account_IDs, account_type, account_name);
        // GetAccountID(account_IDs);
    else 
        BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует элемент account_dtls. Счет для поручения не может быть установлен.');
        TableUpdate(STable, List('info='+'Отсутствует элемент account_dtls. Счет для поручения не может быть установлен.'));
    end;

    // ==========================================================
    //                    --- account_holder ---
    // ==========================================================
    v_AccH_ids := List();
    if x_main.?account_holder then
        x_account_dtls := x_main._account_holder;
        //_F_IXML150->Inp_account_holder(x_account_dtls, holder_IDs, acc_holder_Name);
        _F_IXML150->Inp_party_id_name_account_holder(x_account_dtls, v_AccH_ids, account_holder_party_name);
    else 
        BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует элемент account_holder. Владелец счета не может быть установлен.');
    end;

    // ==========================================================
    //              --- account_section_dtls ---
    // ==========================================================
    // по описанию '2.Приложение№1_(R03-1 и R03-2)-v5-2.doc' информация из 
    // данного тэга не требуется

    // ==========================================================
    //             --- account_section_holder ---
    // ==========================================================
    // по описанию '2.Приложение№1_(R03-1 и R03-2)-v5-2.doc' информация из 
    // данного тэга не требуется

    // ==========================================================
    //                --- autorised_person ---
    // ==========================================================
    v_autorised_person_ids := List();     // идентификационная информация вытащенная из тэгов <party_id>
    if x_main.?autorised_person then
        x_autorised_person := x_main._autorised_person;
        _F_IXML150->Inp_autorised_person(x_autorised_person, v_autorised_person_s_type, authorised_person_type, v_autorised_person_ids, bases_of_powers, Info);
    end;

    // ==========================================================
    //
    //                  --- transaction ---
    //
    // ==========================================================
    // Описание операции с ценными бумагами.   
    //          ОБЯЗАТЕЛЬНО:                   - сумма сделки - в случае перерегистрации прав собственности на ЦБ в реестре акционеров/ПИФ, расчетах на условиях ППП (DVP)
    if x_main.?transaction then
        x_transaction := x_main._transaction;
        //    --- transaction/based_info ---
        if (x_transaction.?based_info) then
            Info := '';    
            _F_IXML150->Inp_based_info_table(x_transaction._based_info, v_based_info, Info);
        else
            BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует обязательный элемент based_info.');
        end; 

        //    --- transaction/security ---     
        if (x_transaction.?security) then
            _F_IXML150->Inp_security_info(x_transaction._security, v_security_code, v_proprietary_security_code, v_NumReg, v_ISIN, v_CFI);
        elsif (x_transaction.?mortgages) then
            dummy
        else
            BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует обязательное описание ЦБ (security или mortgages).');
        end;
    
        //    --- transaction/quantity ---
        if (x_transaction.?quantity) then
            v_AMOUNT := _F_IXML150->Inp_Quantity_in_unit(x_transaction._quantity);
            dummy
        else
            BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует обязательный блок quantity');
        end;
    
        //    --- transaction/settlement_amount ---
        if (x_transaction.?settlement_amount) then
            _F_IXML150->Inp_currency_and_amount(x_transaction._settlement_amount, v_ccy_code, v_ccy_amount);
        end;    
    
        //      --- transaction/contragent ---
        // Блок информации о Контрагентах – может быть множественный, т.е. повторяться множество раз,
        // Но 1 раз должен быть указан в этих типах поручений – обязательно.
        // Первым блоком указывается информация о Контрагенте в месте расчетов,
        // Вторым, при определенных расчетах в ВЭбе или реестрах Паев, может быть указана информация о конечном владельце ЦБ.
        Info_cr    := '';
        ContrCount := 0;    
        if (x_transaction.?contragent) then
            x_contragent := x_transaction._contragent;
            x_contragent.@First;
            inc(ContrCount);
            _F_IXML150->Inp_party_dtls(x_contragent,
                                    v_contr_stype, v_contr_full_name, v_contr_nationality, v_contr_inn, v_contr_birthdate, v_contr_place_of_birth, v_contr_doc_type, v_contr_doc_type_xml,
                                    v_contr_doc_ser, v_contr_doc_num, v_contr_doc_dat, v_contr_DOC_PLACE, v_contr_OGRN, v_contr_OGRN_PLACE, v_contr_OGRN_DATE, Info_cr);
            BErrList := _F_REPORT->Add_Info(BErrList, Info_cr);                           
            // Возможно что есть второй блок про второго контрахенту                      
            Info_cr := '';        
            if ~x_contragent.@EOF then
                x_contragent.@Next;
                inc(ContrCount);
                _F_IXML150->Inp_party_dtls(x_contragent,
                                        v_contr_stype_2, v_contr_full_name_2, v_contr_nationality_2, v_contr_inn_2, v_contr_birthdate_2, v_contr_place_of_birth_2, v_contr_doc_type_2, v_contr_doc_type_xml_2,
                                        v_contr_doc_ser_2, v_contr_doc_num_2, v_contr_doc_dat_2, v_contr_DOC_PLACE_2, v_contr_OGRN_2, v_contr_OGRN_PLACE_2, v_contr_OGRN_DATE_2, Info_cr);            
            end;
            BErrList := _F_REPORT->Add_Info(BErrList, Info_cr);                                   
        end;    
    else
        BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует обязательный элемент transaction.');
    end;

    // ============================================================
    //              --- data_storag/account_depo_id --
    //           -- data_storag/account_section_depo_id --
    //                   'ds' - data_storage
    // ============================================================
    Info_cr := '';
    if x_main.?data_storag then
        x_data_storag := x_main._data_storag;
        _F_IXML150->Inp_data_storag_v02(x_data_storag, 
                                        v_account_depo_id, v_account_section_depo_id, v_data_storag_party_name, ds_account_storage_ids, ds_account_section_storage_ids, Info_cr);
        if ~isBlank(Info_cr) then
            BErrList := _F_REPORT->Add_Info(BErrList, Info_cr);
        end    
    else
        BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует обязательный элемент data_storag.');
    end;

    // ============================================================
    //              --- data_storag_new/account_depo_id --
    //           -- data_storag_new/account_section_depo_id --
    //                   'dsnw' - data_storage_new
    // ============================================================
    Info_cr := '';
    v_new_account_depo_id            := '';
    v_new_account_section_depo_id    := '';
    v_data_storag_new_party_name     := '';
    dsnw_account_storage_ids         := List();
    dsnw_account_section_storage_ids := List();

    if x_main.?data_storag_new then
        x_data_storag_new := x_main._data_storag_new;
        _F_IXML150->Inp_data_storag_v02(x_data_storag_new, 
                                        v_new_account_depo_id, v_new_account_section_depo_id, v_data_storag_new_party_name, dsnw_account_storage_ids, dsnw_account_section_storage_ids, Info_cr);
        if ~isBlank(Info_cr) then
            BErrList := _F_REPORT->Add_Info(BErrList, Info_cr);
        end    
    else
        BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует обязательный элемент data_storag.');
    end;

    //................................................................
    //................................................................

    // ==========================================================
    //                    --- add_info ---
    // ==========================================================
    if x_main.?add_info then 
        ListAdd(v_add_info, x_main._add_info);
    end;

   _Metal_F->XML_Close;
except
    //--------------------------
    // Будет регистрация входящего ЗЖРД с минимальными данными. входящая ЗЖРД привязана к Входящему сообщению.
    TableInsert(LoLog, List('rekviz=','tags_descr=' ,'tags=' , 'critic=2','Info=Непредвиденная ошибка при разборе XML содержимого документа № ' + str(%PPnum) + ' от ' + str(%PPData) + ':' + replace(Exception.Text,#13+#10, ' ')));  
    // --------------------------
    _Metal_F->XML_Close;
end;

// --------------------------------------- Вычисляем реквизиты, ровно в таком виде как описано в ТЗ -------------------------------------
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

// ----------  SYS_NAME   ------------------------------------------------------------------------------------------------------------------
SYS_NAME := 'I_CLISER_PEREMES';

// ----------  DIRECTION   --------------------------------------------------------------------------------------------------------------
DIRECTION := 0; //входящий

// ----------  PARAM   ------------------------------------------------------------------------------------------------------------------
PARAM := 5113998;   //Поручение на ПЕРЕМЕЩЕНИЕ ценных бумаг (изменение места хранения ЦБ) - R03-4

// ----------  PASS_KIND (Тип подачи поручения) -----------------------------------------------------------------------------------------
PASS_KIND := 8;

// ----------  D_DATE (Дата документа) --------------------------------------------------------------------------------------------------
// TableInsert(LoLog, List('rekviz=CLIENT', 'tags_descr=..\account_dtls\account_id', 'tags='+str(Account), 'critic=1','Info=Счет с номером '+ str(ACCOUNT)+' в справочнике не найден.'));
try
    D_DATE    := date(now);
except
    TableInsert(LoLog, List('rekviz=D_DATE', 'tags_descr=', 'tags=', 'critic=1','Info=Ошибка приведения текущей даты к типу Date'));
end;

// ----------  NUM (Номер документа) ----------------------------------------------------------------------------------------------------
// № полученный по стандартной процедуре (следующий №) от D_DATE
try
    NUM       := _F_DOC->NextDocumentNum( SYS_NAME, D_DATE, DIRECTION );
except
    TableInsert(LoLog, List('rekviz=NUM', 'tags_descr=SYS_NAME', 'tags='+SYS_NAME, 'critic=1','Info=Не получилось взять следующий номер документа для категории '+SYS_NAME));
end;


// ----------  CLIENT (Клиент) ----------------------------------------------------------------------------------------------------------
// <account_dtls><account_id><id>

CLIENT     := clear(0);
if (ListCount(account_IDs))>0 then
    // В ТЗ нет указанаия какой из account_id брать берем первый попавшийся.
    Account := Token(ListGet(account_IDs, 0),';',1);
    CLIENT  := _F_IXML150->GetClientByNumber(Account);
    if isBlank(CLIENT) then
        BErrList := _F_REPORT->Add_Info(BErrList, 'Счет с номером '+ str(ACCOUNT)+' в справочнике не найден.');
        TableInsert(LoLog, List('rekviz=CLIENT', 'tags_descr=..\account_dtls\account_id\id', 'tags='+str(Account), 'critic=1','Info=Счет с номером '+ str(ACCOUNT)+' в справочнике не найден.'));
    elsif (_F_IXML150.GetClientByNumber.STATE = 2) then
        BErrList := _F_REPORT->Add_Info(BErrList, 'Счет с номером '+ str(ACCOUNT)+' закрыт.');
        TableInsert(LoLog, List('rekviz=CLIENT', 'tags_descr=..\account_dtls\account_id\id', 'tags='+str(Account), 'critic=1','Info=Счет с номером '+ str(ACCOUNT)+' закрыт.'));        
    end
else    
    TableInsert(LoLog, List('rekviz=CLIENT', 'tags_descr=..\account_dtls\account_id\id', 'tags='+str(Account), 'critic=1','Info=Не удается вычислить реквизит, так как значение тэга-источника пусто')); 
end;

// ----------  FROM_FACE   -------------------------------------------------------------------------------------------------------------- 
// 1) Если во вх.поручении заполнен необязательный тэг <autorised_person>
_rstroka_1 := ''; _rstroka_2 := '';
FROM_FACE := -1;
if ~isNull(x_autorised_person) then
    //значение<autorised_person><authorised_person_type> =12,13,08
    if authorised_person_type in List(8,12,13) then
        _rstroka_1  := '..\autorised_person\authorised_person_dtls';
        _rstroka_2  := str(v_autorised_person_ids);
        FROM_FACE :=_F_IXML150->FindFACE_ap( v_autorised_person_ids, v_autorised_person_s_type);
    end;
else
    //2) Если во вх.поручении НЕ заполнен необязательный тэг<autorised_person>
    //   Это означает, что поручение подает и подписывает владелец счета депо и FROM_FACE будет определяться по анализу тега :<account_holder><party_id><id>
    cc2 := ListCount(v_AccH_ids);
    if cc2>0 then _rstroka_1  := '..\account_holder\party_id';dec(cc2);end;
    While cc2>0 do
        _rstroka_1  := _rstroka_1 + '#' + '..\account_holder\party_id';
        dec(cc2);
    End;    
    _rstroka_2  := _rstroka_2 + iif(length(_rstroka_2)>0,'#','') + replace(str(v_AccH_ids), #13+#10, '#');    
    // FindFACE_accH( %Attributes: list; s_type: int): int    
    FROM_FACE := _F_IXML150->FindFACE_accH(v_AccH_ids, v_autorised_person_s_type);        
end;

if FROM_FACE<0 then
    //Делаем заметку что всё плохо и идем вычислять следующий реквизит
    //2.3)данный реквизит считается «Не Заполненным!», 
    //В лог.файл и в общее сообщение обо всех ошибка по ЕМАЙЛ , заноситься информация о том:
    //«при распаковке вх.сообщения поручения № от дата не определен обязательный реквизит формы поручения: «Имя реквизита»,  по информации из вх.документа: «значение тэга:<…>»
    TableInsert(LoLog, List('rekviz=FROM_FACE', 'tags_descr='+_rstroka_1, 'tags='+_rstroka_2, 'critic=1','Info=Не удается вычислить реквизит, субъект отсутствует в справочниках')); 
end;

// ----------  SHARE   -------------------------------------------------------------------------------------------------------------- 
SHARE := NULL; cc2 :=0;
_rstroka_1 := ''; _rstroka_2 := '';

if ~isNull(x_transaction) then
    if ListCount(v_security_code)>0 then             _rstroka_1 := _rstroka_1 + '..\security\security_code'; _rstroka_2 := _rstroka_2 + v_security_code; end;
    if ListCount(v_proprietary_security_code)>0 then _rstroka_1 := _rstroka_1 + '#' + '..\security\proprietary_security_code'; _rstroka_2 := _rstroka_2 + '#' + v_proprietary_security_code; end;
    if ~isBlank(v_NumReg) then                       _rstroka_1 := _rstroka_1 + '#' + '..\security\state_reg_num'; _rstroka_2 := _rstroka_2 + '#' + v_NumReg;end;
    if ~isBlank(v_ISIN) then                         _rstroka_1 := _rstroka_1 + '#' + '..\security\ISIN_identifier'; _rstroka_2 := _rstroka_2 + '#' + v_ISIN;end;
    if ~isBlank(v_CFI) then                          _rstroka_1 := _rstroka_1 + '#' + '..\security\security_classification_CFI'; _rstroka_2 := _rstroka_2 + '#' + v_CFI;end;
    //FindShare( %Attributes, %Attributes_prop: list; %v_NumReg, %v_ISIN, %v_CFI: str)
    // Передаем в FindShare два списка с кодами идентификации ценной бумаги. Список v_security_code всегда состоит из 1 записи.
    SHARE :=_F_IXML150->FindShare( v_security_code, v_proprietary_security_code, v_NumReg, v_ISIN, v_CFI);
    if (isNull(SHARE)) then
        TableInsert(LoLog, List('rekviz=SHARE', 'tags_descr=' +_rstroka_1, 'tags=' + _rstroka_2, 'critic=1','Info=Не удается вычислить реквизит. Финансовый инструмент отсутствует в справочниках')); 
    end;
else
    // Такой случай в штатной работе конечно не возможен - отсутствие тэге transaction должно обнаружится на этапе валидации документа XML согласно XSD схеме. 
    TableInsert(LoLog, List('rekviz=SHARE', 'tags_descr=transaction', 'tags=', 'critic=1','Info=Не удается вычислить реквизит, так как отсутствует источник данных.')); 
    BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует обязательный элемент transaction.');
end;

// -----------  LINE   -------------------------------------------------------------------------------------------------------------- 
LINE := NULL;
_rstroka_1 := 'tags_descr='; _rstroka_2 := 'tags=';
if ~isNull(x_data_storag) then
    //v_security_code, v_proprietary_security_code, v_NumReg, v_ISIN, v_CFI
    //                  FindStorage( %AccPlan: int; %Storage_ids, %Storage_Sect_ids  : list; %v_account_depo_id, %v_account_section_depo_id: str; %share: int): int
    if ListCount(ds_account_storage_ids)>0 then         _rstroka_1 := _rstroka_1 + '..\account_storage_id'; _rstroka_2 := _rstroka_2 + ds_account_storage_ids; end;
    if ListCount(ds_account_section_storage_ids)>0 then _rstroka_1 := _rstroka_1 + '#' + '..\account_section_storage_id'; _rstroka_2 := _rstroka_2 + '#' + ds_account_section_storage_ids; end;
    if ~isBlank(v_account_depo_id) then                 _rstroka_1 := _rstroka_1 + '#' + '..\account_depo_id'; _rstroka_2 := _rstroka_2 + '#' + v_account_depo_id;end;
    if ~isBlank(v_account_section_depo_id) then         _rstroka_1 := _rstroka_1 + '#' + '..\account_section_depo_id'; _rstroka_2 := _rstroka_2 + '#' + v_account_section_depo_id;end;
    LINE := _F_IXML150->FindStorage(AccPlan, ds_account_storage_ids, ds_account_section_storage_ids, v_account_depo_id, v_account_section_depo_id, SHARE);    
    if isNull(LINE) then
        BErrList := _F_REPORT->Add_Info(BErrList, 'Не удалось определить место хранения.');
        TableInsert(LoLog, List('rekviz=LINE',_rstroka_1, _rstroka_2, 'critic=1', 'Info=Не удается вычислить реквизит. Место хранения в справочниках не найдено'));     
    end;
else
    // Такой случай в штатной работе конечно невозможен - отсутствие тэге transaction должно обнаружиться на этапе валидации документа XML согласно XSD схеме. 
    TableInsert(LoLog, List('rekviz=LINE', 'tags_descr=..\data_storag', 'tags=', 'critic=1', 'Info=Не удается вычислить реквизит, так как отсутствует обязательный элемент data_storag'));     
    BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует обязательный элемент data_storag.');
end;

// ----------  CAGENT (Контрагент) ------------------------------------------------------------------------------------------------------
// <data_storag_new><account_depo_id> или <data_storag_new><account_section_depo_id>
// <data_storag_new><account_storage_id><party_id><id> или <data_storag_new><account_section_storage_id><party_id><id>
// v_new_account_depo_id, v_new_account_section_depo_id, v_data_storag_new_party_name, dsnw_account_storage_ids, dsnw_account_section_storage_ids,
CAGENT := null;
_rstroka_1 := 'tags_descr='; _rstroka_2 := 'tags=';
if ~isNull(x_data_storag_new) then
    //v_security_code, v_proprietary_security_code, v_NumReg, v_ISIN, v_CFI
    //                  FindStorage( %AccPlan: int; %Storage_ids, %Storage_Sect_ids  : list; %v_account_depo_id, %v_account_section_depo_id: str; %share: int): int
    if ListCount(dsnw_account_storage_ids)>0 then         _rstroka_1 := _rstroka_1 + '..\account_storage_id'; _rstroka_2 := _rstroka_2 + dsnw_account_storage_ids; end;
    if ListCount(dsnw_account_section_storage_ids)>0 then _rstroka_1 := _rstroka_1 + '#' + '..\account_section_storage_id'; _rstroka_2 := _rstroka_2 + '#' + dsnw_account_section_storage_ids; end;
    if ~isBlank(v_new_account_depo_id) then                 _rstroka_1 := _rstroka_1 + '#' + '..\account_depo_id'; _rstroka_2 := _rstroka_2 + '#' + v_new_account_depo_id;end;
    if ~isBlank(v_new_account_section_depo_id) then         _rstroka_1 := _rstroka_1 + '#' + '..\account_section_depo_id'; _rstroka_2 := _rstroka_2 + '#' + v_new_account_section_depo_id;end;
    CAGENT := _F_IXML150->FindStorage(AccPlan, dsnw_account_storage_ids, dsnw_account_section_storage_ids, v_new_account_depo_id, v_new_account_section_depo_id, SHARE);    
    if isNull(CAGENT) then
        BErrList := _F_REPORT->Add_Info(BErrList, 'Не удалось определить место хранения.');
        TableInsert(LoLog, List('rekviz=CAGENT',_rstroka_1, _rstroka_2, 'critic=1', 'Info=Не удается вычислить реквизит. Место хранения в справочниках не найдено'));     
    end;
else
    // Такой случай в штатной работе конечно невозможен - отсутствие тэге transaction должно обнаружиться на этапе валидации документа XML согласно XSD схеме. 
    TableInsert(LoLog, List('rekviz=CAGENT', 'tags_descr=..\data_storag_new', 'tags=', 'critic=1', 'Info=Не удается вычислить реквизит, так как отсутствует обязательный элемент data_storag'));     
    BErrList := _F_REPORT->Add_Info(BErrList, 'Отсутствует обязательный элемент data_storag.');
end;

// -----------  G_TEXT  -------------------------------------------------------------------------------------------------------------- 
G_TEXT := v_add_info;

// -----------  AMOUNT  -------------------------------------------------------------------------------------------------------------- 
if ~isBlank(v_AMOUNT) then
    if v_NumReg = '10302307B' then
        AMOUNT := v_AMOUNT/1000000;
    else
        AMOUNT := float(v_AMOUNT);
    end;
else
    BErrList := _F_REPORT->Add_Info(BErrList, 'Значение элемента AMOUNT пусто');
    TableInsert(LoLog, List('rekviz=AMOUNT', 'tags_descr=..\quantity\units', 'tags=', 'critic=1','Info=Не удается вычислить реквизит, так как отсутствует источник данных.'));
end;
   
// -----------  G_CLASS, G_NUM, G_DATE ----------------------------------------------------------------------------------------------- 
// transaction><based_info><contract_type><contract_code>
Info_cr    := '';
if (ListCount(v_based_info)>0) then
    //FindBases(%L_bases:List; doc_type:int; doc_type_code, doc_num: str; doc_date: date; OtherBases:List; Info_str: str)
    // Формат списка v_based_info :  doc_type;doc_num;doc_date;doc_validity;doc_narrative;doc_type_code
    _F_IXML150->FindBases(v_based_info, v_doc_type, v_doc_type_code, G_NUM, G_DATE, v_bi_other, Info_cr);
    //G_CLASS := Extract('Данные', [select NUM from OD_SYS_TABS where ALT = :ALT], v_doc_type);
    if ~isNull(v_doc_type) then
        G_CLASS  := v_doc_type;    
    else
        BErrList := _F_REPORT->Add_Info(BErrList, 'Не удается определить реквизит G_CLASS по системному классификатору. Значение xml тэга contract_type='+str(v_doc_type));
        TableInsert(LoLog, List('rekviz=G_CLASS', 'tags_descr=..\contract_type\contract_code', 'tags='+v_doc_type_code, 'critic=1','Info=Не удается вычислить реквизит, так как отсутствует источник данных.'));       
    end;
end;    
G_TEXT  := G_TEXT + v_bi_other;
    
// -----------  D1_NUM, D1_DATE  -------------------------------------------------------------------------------------------------------- 
D1_NUM := null; D1_DATE := null;
if ~isBLank(CLIENT) then
    try
        ExtractSQL('Данные', [select c.DD_NUM, c.DD_DATE
                              from OD_CLIENTS c
                              where c.ID = :ID], CLIENT, D1_NUM, D1_DATE);
    except
        TableInsert(LoLog, List('rekviz=D1_NUM', 'tags_descr=CLIENT', 'tags='+str(CLIENT), 'critic=0','Info=Не удается вычислить реквизит, ошибка при выполнении запроса к Базе данных'));
        TableInsert(LoLog, List('rekviz=D1_DATE', 'tags_descr=CLIENT', 'tags='+str(CLIENT), 'critic=0','Info=Не удается вычислить реквизит, ошибка при выполнении запроса к Базе данных'));
    end;
    if isBlank(D1_NUM) then
        TableInsert(LoLog, List('rekviz=D1_NUM', 'tags_descr=CLIENT', 'tags='+str(CLIENT), 'critic=0','Info=Не указан номер депозитарного договора в справочнике по счету SELF_ID='+str(CLIENT)));
    end;
    if isBlank(D1_DATE) then
        TableInsert(LoLog, List('rekviz=D1_DATE', 'tags_descr=CLIENT', 'tags='+str(CLIENT), 'critic=0','Info=Не указана дата депозитарного договора в справочнике по счету SELF_ID='+str(CLIENT)));
    end;
    
else
    TableInsert(LoLog, List('rekviz=D1_NUM', 'tags_descr=CLIENT', 'tags=', 'critic=0','Info=Не удается вычислить реквизит, так как отсутствует источник данных.'));       
    TableInsert(LoLog, List('rekviz=D1_DATE', 'tags_descr=CLIENT', 'tags=', 'critic=0','Info=Не удается вычислить реквизит, так как отсутствует источник данных.'));       
end;
   
//
iif(%mute, dummy, DoProgress(1, 1, 1));
iif(%mute, dummy, DoProgress(2, 0, 1));

// Создание нового документа 
D_CAT  := Extract('Данные', "select ID from OD_DOC_CATS where SYS_NAME='"+SYS_NAME+"'");

// ---------------------------------------------------------------------------------------------
// Проверка был ли ранее в этот опер.день обработан документ по такому же счету депо (CLIENT) 
// с такими же номерами
cc  := 0;
rez := 0;
DD1 :=clear(0); DD2:=clear(0); ErrStr := '';
if (~isBlank(CLIENT)) then
    // Проверка было ли в прошлом обработано поручение с таким же doc_num, doc_date, CLIENT с порождением экземпляра депозитарного поручения
    cc := Extract('Данные', [select count(i.doc)
                             from OD_IN_DOCS i
                                 left join OD_DOCS di on di.KVIT = i.DOC
                                 left join D_CLISER_ZA_SP z on z.DOC = di.ID
                             where z.CLIENT = :DEPO and f_copy(Upper(i.THEIR_NUM), 1, f_RightPos('_', Upper(i.THEIR_NUM))-1) = :PNum and f_date(i.THEIR_DATE) = :PDate], 
                        CLIENT, UpperCase(PNum), PData);
    if (cc = 0) then
        // Проверка было ли в прошлом обработано поручение с таким же doc_num, doc_date, CLIENT без порождением экземпляра депозитарного поручения.
        // В этом случае след должен оставить ЗЖРД в котором прописаны doc_num, doc_date, CLIENT
        cc := Extract('Данные', [select count(i.doc) as FIELD_0 
                                 from OD_IN_DOCS i
	                                 left join OD_STEPS st1 on st1.DOC = i.DOC and st1.S_TYPE = 0 and st1.ERR_CODE = 2004
	                                 left join D_FILER f on f.DOC = st1.A_DOC 
                                 where (f.ACCOUNT = :DEPO)
                                         and dbo.f_copy(Upper(i.THEIR_NUM), 1, dbo.f_RightPos('_', Upper(i.THEIR_NUM))-1) = :PNum 
                                         and dbo.f_date(i.THEIR_DATE) = :PDate], 
                        CLIENT, UpperCase(PNum), PData);
    end;
                        
    if (cc>0) then
       // ErrList := ErrList + #13 + #10 + 'В текущем операционном дне уже обрабатывался документ по счету депо '+_F_DEPO->GetClient(CLIENT) + ' с номером ' + str(Pnum) + #13 + #10; 
       TableInsert(LoLog, List('rekviz=', 'tags_descr=' ,'tags=' , 'critic=2','Info=В текущем операционном дне уже обрабатывался документ по счету депо '+_F_DEPO->GetClient(CLIENT) + ' с номером ' + str(Pnum)));
    end;
    if (~isBlank(FROM_FACE)) then
        TableInsert(PhantomDoc, List('SYS_NAME='+SYS_NAME,
                                 'NUM=' + NUM,
                                 'CONTR_DATE='+str(date(D_DATE)),
                                 'CLIENT='+str(CLIENT),
                                 'CAGENT='+str(CAGENT),
                                 'PARTY_TYPE=',
                                 'FROM_FACE='+FROM_FACE,
                                 'RELATION='
                ));
        rez := _F_IXML150->Check_Affils(PhantomDoc, ErrStr, DD1, DD2);
        if rez <> 0 then
            // Выбранный инициатор не имеет полномочий для действия / тут бы вернуть -24
            TableInsert(LoLog, List('rekviz=', 'tags_descr=' ,'tags=' , 'critic=2','Info=При распаковке вх.сообщения поручения № ' + str(%PPnum) + ' от ' + str(%PPData) + ' по счету депо '+ _F_DEPO->GetClient(CLIENT)+' не определены полномочия инициатора поручения: ' + ErrStr));
        end;           
    end;   
end;
// ---------------------------------------------------------------------------------------------
//В лог.файл и в общее сообщение обо всех ошибка по ЕМАЙЛ , заноситься информация о том:
//«при распаковке вх.сообщения поручения № от дата не определен обязательный реквизит формы поручения: «Имя реквизита»,  по информации из вх.документа: «значение тэга:<…>»

// Готовим ErrList из лог-таблицы
_F_IXML150.GenErrList.Info := List();
ErrTag := _F_IXML150->GenErrList(LoLog, PNum, PData);
ErrList := ErrList + _F_IXML150.GenErrList.Info;

iif(%mute, dummy, DoProgress(2, 1, 1));

// ---------------- Обновим поле 'От кого' у Входящего сообщения ----------
//if ~isBlank(FROM_FACE) and ~isNull(%doc_id) then 
if (FROM_FACE>=0) and ~isNull(%doc_id) then 
  ExecSQL('Данные',[UPDATE OD_IN_DOCS set FROM_FACE=:FACE_FROM, THEIR_DATE=:D_DATE where DOC=:DOC], FROM_FACE, PData, %doc_id);
end;
// ------------------------------------------------------------------------------------------------------

status := '';
err    := 0;
D_ID   := ID;
if ErrTag=0 or ErrTag=1 then
    // Либо нет ошибок, либо были не критические ошибки
    status :='01';    
    MainForm.UserDic.@commit; //Закрываем предыдущую транзакцию
    MainForm.UserDic.@start;
    try
        i := 0;
        while i<21 do
            NUM := _f_doc->NextDocumentNum( SYS_NAME, D_DATE, DIRECTION );
            try    
                ExecSQL('Данные', [insert into OD_DOCS(
                                           ID,  NUM,  PARAM,  D_CAT,  D_DATE,  STATE,            DIRECTION,  WHOS,  KVIT)
                                   values(:ID, :NUM, :PARAM, :D_CAT, :D_DATE, :STATE,           :DIRECTION, :WHOS, :KVIT)],
                                           ID,  NUM,  PARAM,  D_CAT,  D_DATE,  doc_state{STATE}, direction,  WHOS, %DOC_ID);
                 exit;
            except
                if pos( 'Дублирование номера', Exception.text )>0 and i<19 then
                    inc(i);
                    ErrList := ErrList + 'Продублировался номер '+ str(NUM)+'. Попытка '+str(i)+'. Время '+str(now) + #13 +#10;
                else 
                    propagate;
                end;
            end;
        end;  
        ExecSQL('Данные', [insert into D_CLISER_CHANGE (
                                    DOC,  AMOUNT,  CAGENT,  CLIENT,  G_CLASS,  G_DATE,  G_NUM, G_TEXT, LINE, SHARE, PARTY_TYPE, D1_NUM, D1_DATE) 
                           values (:DOC, :AMOUNT, :CAGENT, :CLIENT, :G_CLASS, :G_DATE, :G_NUM, :G_TEXT, :LINE, :SHARE, :PARTY_TYPE, :D1_NUM, :D1_DATE) ],
                                    ID,   AMOUNT,  CAGENT,  CLIENT,  G_CLASS,  G_DATE,  G_NUM, G_TEXT, LINE, SHARE, 1{PARTY_TYPE}, D1_NUM, D1_DATE);

        ExecSQL('Данные', [insert into OD_IN_DOCS (DOC,FROM_FACE,PASS_KIND) values(:DOC, :FROM_FACE, :PASS_KIND)],
                                                   ID, FROM_FACE, PASS_KIND);
        _f_doc->Link_Add(ID, %DOC_ID, 2006); // к входящему сообщению от порождённого им документа
        ExecSQL('Данные', [update OD_DOCS set STATE=:ds, id=0 where ID=:gid], doc_state, ID);  //=============================================
        if ErrTag = 0 then
            err := 0;
        else    
            if not %Mute then
                Warning('При разборе xml поручения сформирован список ошибок/предупреждений.'+#13+#10+#13+#10+ErrList);
            end;
            err := -1;
        end;
        MainForm.UserDic.@commit;  //Открываем транзакцию для следующего отчёта
        MainForm.UserDic.@start;   //Открываем транзакцию для следующего отчёта
        
        //Report('x_T_REP');
    except
        MainForm.UserDic.@rollback;
        //--------------------------
        // регистрация входящего документа
        MainForm.UserDic.@start;
        ErrList := _f_report->Add_Info(ErrList, 'Ошибка при вставке и регистрации документа-поручения: '+Exception.Text);
        D_ID    := %DOC_ID;
        fSTATE  :=0;
        err     := 100; //return(100)
        if not %Mute then
          Warning('При вставке документов произошла непредвиденная ошибка. Сформирован список ошибок/предупреждений.'+#13+#10+#13+#10+ErrList);
        end;
    end; 
else //ErrTag=2 и ErrTag = 3
    //MainForm.UserDic.@commit; //Закрываем предыдущую транзакцию
    //MainForm.UserDic.@start;
    err    := 100;
    D_ID   := %DOC_ID;
    fSTATE := 0;
    // --------------------------
    if not %Mute then
        Warning('При разборе xml поручения сформирован список ошибок/предупреждений.'+#13+#10+#13+#10+ErrList);
    end;
    status:='03';
    //NUM:='#';
    //D_DATE:=str(now());
    //Report('x_T_REP');
end;

try
    //--------------------------
    // регистрация входящего документа
    if MyBase='SDP' then
        //SDP_InDocFiler_Add(%DOC:int; %CONTRACT:int; %FUND:int; %CORR_FACE:int; %DOC_NUM:str; %DOC_DATE:datetime; %NUM:str; %D_DATE:datetime; %COMMENT, %MESS, %FILE_NAME, %CORR_NUM :str; %CORR_DATE:datetime;
        // %PLACE:int; %ACCOUNT:int; %PASS_KIND:int; %RUBRICA :int; %CREATOR :int;%MUTE:int) 
        _f_ixml150.SDP_InDocFiler_Add.STATE := fSTATE; 
        _f_ixml150->SDP_InDocFiler_Add(D_ID, clear(0), clear(0), iif(FROM_FACE>=0,FROM_FACE, clear(0)), PNum, PData, %PPNum, %PPData, COMMENT, body, '', '' {%POutNum}, clear(now),
                Clear(0), CLIENT, 8, RUBRICA, CREATOR, %Mute);
    else
        // InDocFiler_Add(%DOC:int; %CONTRACT:int; %FUND:int; %CORR_FACE:int; %DOC_NUM:str; %DOC_DATE:datetime; %NUM:str; %D_DATE:datetime; %COMMENT, %MESS, %FILE_NAME, %CORR_NUM :str; %CORR_DATE:datetime) :int
        _F_DOC.InDocFiler_Add.PASS_KIND:= PASS_KIND; //ЭДО
        _F_DOC.InDocFiler_Add.RUBRICA  := RUBRICA;
        _F_DOC.InDocFiler_Add.CREATOR  := CREATOR;
        _F_DOC.InDocFiler_Add.ACCOUNT  := CLIENT;
        _F_DOC.InDocFiler_Add.MUTE     := %Mute;
        _F_DOC->InDocFiler_Add(D_ID, clear(0), clear(0), FROM_FACE, PNum, PData, %PPNum, %PPData, COMMENT, body, '', ''{%POutNum}, clear(now));
    end;
    MainForm.UserDic.@commit;  // Фиксируеме транасакцию
    MainForm.UserDic.@start;
    // --------------------------
    status:='03';
    //NUM:='#';
    //D_DATE:=str(now());
    //Report('x_T_REP');
except
    MainForm.UserDic.@rollback;
    MainForm.UserDic.@start;
    ErrList := _f_report->Add_Info(ErrList, 'Ошибка при вставке Записи в журнале регистрации документов: '+Exception.Text);
    if not %Mute then
        Warning('Ошибка при вставке Записи в журнале регистрации документов:' + #13 + #10 + Exception.Text);
    end;
    err     := 100; 
end;

err;